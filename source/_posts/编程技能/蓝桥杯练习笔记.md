---
title: 蓝桥杯练习笔记
tags: [蓝桥杯]
categories: 编程技能
date: 2023-03-01 19:20:00
---
## 方法
### 辗转相除法
```cpp
#include <iostream>

using namespace std;

int fun1(int a, int b) {
    return b == 0? a: fun1(b, a % b);
}

// 迭代法
int fun2(int a, int b) {
    while (b) {
        int k = a % b;
        a = b;
        b = k;
        cout << "b: " << b<<endl;
    }
    return a;
}

int main() {
    int a, b;
    cin >> a >> b;
    cout << fun1(a,b) << endl;
    return 0;
}
```
### 前缀和
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 505;
typedef long long LL;
int s[N][N];
LL result = 0, k;

int main() {
	int n, m;
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d", &s[i][j]);
			s[i][j] += s[i - 1][j] + s[i][j - 1] -s[i- 1][j - 1];
		}
	}
	
	int sum = 0;
	for (int x1 = 1; x1 <= n; x1++) {
		for (int y1 = 1; y1 <= m; y1++) {
			for (int x2 = x1; x2 <= n; x2++) {
				for (int y2 = y1; y2 <= m; y2++) {
					sum = s[x2][y2] - s[x1 - 1][y2] 
						- s[x2][y1 - 1]	+ s[x1 - 1][y1 - 1];
					if (sum <= k) result++;
					else break;
				}
			}
		}
	}
	printf("%lld\n", result);
	return 0;
} 
```
### 存储单位的换算
```cpp
1MB=1024KB
1KB=1024B
1B=8b;
B:byte字节
b:bit比特(1位=1比特)
32位=4B
题解的意思是有多少个32位
转化成long long避免数据溢出
```

- bit(比特)：bit是数据的最小单位，通常简写为b。在计算机中通常用1和0来表示。
- Byte(字节)：数据存储的基本单位，通常简写为B。通常：1Byte=8bit。
### 优先队列
```cpp
priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;
```
### 回文数
### 判断一个数是否为素数
```cpp
#include <bits/stdc++.h> 

using namespace std;

// 判断一个数是否为质数 
bool judge(int x) {
	for (int i = 2; i * i <= x; i++) {
		if (x % i == 0) {
			return false;
		}
	}
	return true;
}

int main() {
	for (int i = 2; i <= 100; i++) {
		if (judge(i)) cout << i << endl; 
	} 
	return 0;
}
```
### 是否为闰年
```cpp
#include <bits/stdc++.h>
using namespace std;

int leapYear(int year) {
    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0; 
}

int main() {
    for (int i = 1900; i <= 2000; i++) {
        if (judge(i)) cout << i << endl;
    }
    return 0;
}
```
### 手写日历
```cpp
int getDate(int yy) {
    for (int y = 2020; y <= yy; y++) {
        if (isRun(y)) month[2] = 29;
        else month[2] = 28;
        for (int m = 1; m <= 12; m++) {
            for (int d = 1; d <= month[m]; d++) {
                printf("%d:%d:%d\n", y, m, d);
            }
        }
    }
}
```
### 手写哈希-开放地址寻址法
```cpp
#include <bits/stdc++.h> 

using namespace std;

typedef long long LL;
const int N = 2e5+3;

LL hash[N];

int find(LL x) {
	int key = (x % N + N) % N; // 这么做是为了防止出现取模后值为负数的情况
	while (hash[key] != 0 && hash[key] != x) {
		key++;
		if (key == N) key = 0;
	}
	return key;
}

int main() {
	
	for (int i = 1; i < 100; i++) {
		for (int j = 1; j < 100; j++) {
			LL number = i*j + j / i;
			hash[find(number)] = number;
		}
	}
	// find number wherever in the array 
	int num;
	cin >> num;
	string flag = hash[find(num)] == 0? "no":"yes"; 
	cout << flag<<endl;;
	cout << "hello world"<<endl;
	return 0;
} 
```
### 回溯算法
### 进制转换
### 精度转换
### 暴力
### DFS
### BFS
### 全排列
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<char> chars = {'a', 'b', 'c'};
  do {
    cout << chars[0] << chars[1] << chars[2] << endl;
  } while (next_permutation(chars.begin(), chars.end()));

  return 0;
}
```
### 排序
```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int main() {
    // 方式一、使用数组
    int a[10] = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
    sort(a, a + 10);  // 10为元素个数

    for (int i = 0; i < 10; i++) cout << a[i] << ' ';		// 输出排序后数组
    cout << endl;

    // 方式二、使用 vector
    vector<int> arr = {9, 6, 3, 8, 5, 2, 7, 4, 1, 0};
    sort(arr.begin(), arr.end());  // 10为元素个数
    for (int i = 0; i < 10; i++) cout << arr[i] << ' ';	// 输出排序后数组

    return 0;
}
```
### 时间限制的估计
1000ms意味着
一般来说你的程序计算次数达到1e8就很容易超时
![](https://cdn.nlark.com/yuque/__latex/50774a3b265cb90b26751bbcc84d74d3.svg#card=math&code=O%28n%5E3%29%0A&id=XL8CG)的算法，  n可以几百，一般题目给的数据范围为100，
![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=ryayx) 的算法， 可以几千，经常出现的就是数据范围1000。
![](https://cdn.nlark.com/yuque/__latex/d87469bfa5b4ac8a4c2970ca5cf5700e.svg#card=math&code=O%28n%29%20%E6%88%96%E8%80%85O%28nlogn%29&id=y4ZoT)的算法，最常见的数据范围就是为100000。
### 时间优化
```cpp
int m=n*2  可改为   m=n<<1;
int m=n/16 可改为   m=n>>4;

int m=100;
while(m%2==1)  可改为  while(m&1)  //若m为奇数则m&1=1,若为偶数则等于0；
```
### 字符类型转换
```cpp
//数值型 转 string
string s = to_string(100);

//string 转 int型
int n = atoi(str.c_str());

//char* 转 int型
int n = atoi(ch);

//string 转 char*
string str = "it";
const char* cstr = str.c_str();

//char* 转 string 
char* s = "it";
string str(s);
```

### string的常用操作
```cpp
//返回由pos开始的n个字符组成的字符串
string substr(int pos = 0, int n = npos) const;

//查找str第一次出现位置,从pos开始查找
int find(const string& str, int pos = 0) const; 

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址
```
### KMP
### 冒泡排序
```cpp
void buble(int a[], int n) {
	for (int i = 0; i < n - 1; i ++) {
		for (int j = 0; j < n - i - 1; j++) {
			if (a[j + 1] < a[j]) {
				swap(a[j + 1], a[j]);
			}
		}
	}
}
```
### 快速排序
### 数组模拟链表
```cpp
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```
## 经验

1. C语言中局部变量数组最大只支持1M,而**全局变量数组没有这个限制**！
2. int（long） 的取值范围： [2 ^ 31 - 1,  2 ^ 31]
3. long long 的取值范围：[2 ^ 63 - 1, 2 ^ 63]
4. 最好不要用memset来初始化
5. 在做填空题的时候要小心，看是否包含当前的数，避免答案与正确答案之间相差1
6. 在图论问题中，如果有多个点，要判断 点会重合的情况
7. memset函数是按照字节对内存块进行初始化，所以不能用它将int数组出初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。
## 真题
### 扫雷
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int BASE = 1e9 + 1;
const int MAX = 999997;

LL hash1[MAX];
int number[MAX], rMax[MAX], visited[MAX];
int result = 0;


// 将二维数据压缩成一维 
LL to_base(int x, int y) {
	return (LL)x * BASE + y;
}

// 手写哈希表-开放地址法 
LL find(LL x) {
	int key = (x % MAX + MAX) % MAX;
	while (hash1[key] != -1 && hash1[key] != x) {
		key++;
		if (key == MAX) key = 0;
	}
	return key;
}

// 判断点是否在圆内 
int judge(int x1, int y1, int x2, int y2, int r) {
	return pow(x1 - x2, 2) + pow(y1 - y2, 2) <= r * r;
}

// 深度搜索 
void dfs(int x, int y, int r) {
	for (int i = x - r; i <= x + r; i++) {
		for (int j = y - r; j <= y + r; j++) {
			LL base = to_base(i, j);
			if (number[find(base)] && judge(x, y, i, j, r) && !visited[find(base)]){
				result += number[find(base)];
				visited[find(base)] = 1;
				dfs(i, j, rMax[find(base)]);
			}
		} 
	}
}


int main() {
	
	int n, m;
	memset(hash1, -1, sizeof(hash1));
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++) {
		int x, y, r;
		scanf("%d%d%d", &x, &y, &r);
		LL base = to_base(x, y);
		hash1[find(base)] = base;
		number[find(base)]++;
		rMax[find(base)] = max(r, rMax[find(base)]);
	}
	for (int i = 0; i < m; i++) {
		int x, y, r;
		scanf("%d%d%d", &x, &y, &r);
		dfs(x, y, r);
	}
	printf("%d", result);
	return 0;
} 
```
