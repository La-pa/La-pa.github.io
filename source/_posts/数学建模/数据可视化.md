---
title: 数据可视化
tags: [数学建模, 机器学习, 数据处理]
categories: 数学建模
date: 2023-03-01 19:20:00
---
## 基本操作
### 导包
```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```
### 显示中文
```python
# 支持中文
plt.rcParams['font.sans-serif'] = ['SimSun']  # 用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号
```
### 将图片中的英文设置成新罗马
```python
plt.rcParams['font.sans-serif'] = ['Times New Roman'] 
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号
```
### 设置全局字体
```python
plt.rcParams['font.size'] = 12 # 小四字体
```
### 图片尺寸设置
```python
A4大小的纸张，默认页边距为2.5cm
宽度范围：(17.72cm, 19.27cm) 或 (6.97英寸, 7.59英寸)
高度范围：(23.19cm, 24.94cm) 或 (9.13英寸, 9.81英寸)
figsize单位为英尺
```
### 调整全局样式
```python
plt.rcParams['lines.linewidth'] = 8
plt.rcParams['lines.color'] = "red"
plt.rcParams['lines.linestyle'] = "--"
```
### 基本操作
```python
plt.figure(num=2,figsize=(13,4))

plt.plot(y_test, color="cornflowerblue", linewidth=2.0,linestyle="-", label='y_test')
plt.plot(y_predict, color="darkorange", linewidth=2.0,linestyle="-", label='y_predict')

figname = 'Title'
plt.title(figname)

plt.xlabel('x')
plt.ylabel('y')

plt.xlim((-2, 4))
plt.ylim((-5, 15))

plt.legend()

plt.savefig("{}.svg".format(figname), dpi=300,format="svg", bbox_inches='tight')

plt.show()
```
### 导出图片
```python
for i in range(1):
	plt.savefig("test{}.svg".format(i), dpi=300,format="svg", bbox_inches='tight')

# 通过format可以批量导出图片
# format 保存的格式
# dpi画质
```
## 常见图片
### 热力图
### 箱线图
```python
plt.figure(figsize=(7.6,2.5))
figname = '***箱线图'
plt.title(figname)
df.boxplot()
plt.grid(False)  # 显示网格
plt.xlabel('问题')
plt.ylabel('数值')
plt.savefig("{}.svg".format(figname), dpi=300,format="svg", bbox_inches='tight')
plt.show()
```
```python
labels = 'A', 'B', 'C', 'D', 'E', 'F'
A = [0.4978, 0.5764, 0.5073, 0.5609]
B = [0.5996, 0.65, 0.6251, 0.6473]
C = [0.6015, 0.687, 0.6237, 0.6761]
D = [0.5918, 0.6999, 0.6343, 0.6947]
E = [0.577, 0.6932, 0.6593, 0.7036]
F = [0.5637, 0.7161, 0.6683, 0.697]
plt.grid(True)  # 显示网格
plt.boxplot([A, B, C, D, E, F],
            medianprops={'color': 'red', 'linewidth': '1.5'},
            meanline=True,
            showmeans=True,
            meanprops={'color': 'blue', 'ls': '--', 'linewidth': '1.5'},
            flierprops={"marker": "o", "markerfacecolor": "red", "markersize": 10},
            labels=labels)
plt.yticks(np.arange(0.4, 0.81, 0.1))
plt.show()
```
### 雷达图
```python
plt.figure(figsize=(7.6,5))
data=df.iloc[:, **].value_counts()
dataset = pd.DataFrame(data)

radar_labels=dataset.index
nAttr=len(dataset.index)
nAttr
data=dataset.values #数据值
data_labels=dataset.columns
# 设置角度
angles=np.linspace(0,2*np.pi,nAttr,
                   endpoint= False)
data=np.concatenate((data, [data[0]])) 
angles=np.concatenate((angles, [angles[0]]))
# 设置画布
fig=plt.figure(facecolor="white",figsize=(7.6,5))
plt.subplot( polar=True)
# 绘图
plt.plot(angles,data,'o-',
         linewidth=1.5, alpha= 0.2)
# 填充颜色
plt.fill(angles,data, alpha=0.25) 
plt.thetagrids(angles[:-1]*180/np.pi, 
               radar_labels,1.2) 

plt.setp(legend.get_texts(), 
         fontsize='large') 
plt.grid(True)
figname = "**".format(i)
plt.title(figname)
plt.savefig("./雷达图/{}.svg".format(figname), dpi=300,format="svg", bbox_inches='tight')
plt.show()
```
### 条形图
```python
import matplotlib.pyplot as plt
import numpy as np

# 输入统计数据
x_lable = ('站立', '静坐', '平躺', '行走', '上楼', '下楼')
x_train_number = [1190, 1175, 800, 1200, 1380, 1360]
x_test_number = [580, 410, 400, 590, 570, 610]

bar_width = 0.2  # 条形宽度
index_x_train = np.arange(len(x_lable))  # 训练集条形图的横坐标
index_x_test = index_x_train + bar_width  # 测试集条形图的横坐标

# 使用两次 bar 函数画出两组条形图
plt.bar(index_x_train, height=x_train_number, width=bar_width, color='#0066CC', label='训练集')
plt.bar(index_x_test, height=x_test_number, width=bar_width, color='#339966', label='测试集')

plt.legend(loc="upper left", prop={"size": 12, })  # 显示图例  设置图例的大小和方向

plt.yticks(fontsize=16, color='#000000')  # 改变纵坐标刻度的大小
plt.xticks(index_x_train + bar_width / 2, x_lable, size=16)  
# 让横坐标轴刻度显示 x_lable中的动作类型， index_x_train + bar_width/2 为横坐标轴刻度的位置

# plt.ylabel(' ')  # 纵坐标轴标题
# plt.title(' ')  # 图形标题

plt.show()
```
### 水平条形图
```python
data=df.iloc[:, **].value_counts()
plt.figure(num=2,figsize=(7.6,3.0))
plt.barh(data.index, width=data.values, color=("#FF6D60", "skyblue","#F7D060"
                                               ,'#9376E0','#FDCEDF', "#243763"))
figname = ""
plt.title(figname)
plt.xlabel('*')
plt.ylabel('*')
plt.savefig("./水平条形图/{}.svg".format(figname), dpi=300,format="svg", bbox_inches='tight')
plt.show()
```
### 散点图
```python
plt.figure(num=2,figsize=(13,4))
plt.title('Title')
plt.scatter(range(len(y_test)), y_test, color="cornflowerblue", linewidth=2.0,linestyle="-", label='y_test')

plt.xlabel('x')
plt.ylabel('y')

plt.legend()
plt.show()
```
### 饼状图
```python
data=df.iloc[:, i].value_counts()
plt.figure(num=2,figsize=(3.8,3.8))
plt.pie(data.values,
        labels=data.index,  # 设置饼图标签
        autopct="(%1.1f%%)" , #饼块内标签。
        colors=("#FF6D60", "skyblue","#F7D060",'#9376E0','#FDCEDF'),
        )
figname = "问题{}的分布占比图".format(i)
plt.title(figname)
plt.savefig("./饼状图/{}.svg".format(figname), dpi=300,format="svg", bbox_inches='tight')
plt.show()
```
```python
plt.figure(num=2,figsize=(13,4))
y = np.array([30, 24, 16, 30])
plt.pie(y,
        labels=['Windows', 'Linux', 'ios', 'Android'],  # 设置饼图标签
        autopct="(%1.1f%%)" , #饼块内标签。
        colors=("r", "blue","#88c999", (1, 1, 0)),
        #设置各饼块的颜色，r表示red，blue代表蓝色
        #88c998十六进制表示绿色 （1,1,0）以元组形式表示黄色
        explode=[0, 0, 0.1, 0] #
        )
plt.title("操作系统使用占比")
plt.show()
```
### 折线图
### 词云图
注意如果是中文词语，需要用jieba对句子进行分词处理。
```python
from wordcloud import WordCloud
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

# 设置中文字体路径
font_path = 'C:\Windows\Fonts\simsun.ttc'

# 创建一个词云对象，并设置中文字体
wordcloud = WordCloud(font_path=font_path, background_color='white', width=1000,#宽度
                height=600,#高度
                     )

# 读取文本文件并生成词云图
with open('text.txt', 'r', encoding='utf-8') as file:
    text = file.read()
    wordcloud.generate(text)

# 显示词云图
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.show()

```

