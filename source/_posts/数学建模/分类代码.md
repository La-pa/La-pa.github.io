---
title: 分类代码
tags: [数学建模, 机器学习, 数据处理]
categories: 数学建模
date: 2023-03-01 19:20:00
---
## KNN算法
#### 代码
```python
from sklearn.neighbors import KNeighborsClassifier

k = *
estimator = KNeighborsClassifier(n_neighbors = k)
estimator.fit(x_train, y_train)
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
#### 数据可视化
## 决策树
#### 代码
```python
from sklearn.tree import DecisionTreeClassifier
estimator = DecisionTreeClassifier()
estimator.fit(X_train, y_train)
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
#### 决策树的可视化
将dot的代码复制到[http://webgraphviz.com/](http://webgraphviz.com/)就可以将决策树可视化出来
```python
from sklearn.tree import export_graphviz
export_graphviz(estimator, out_file="decision_tree.dot", feature_names=data.columns)
```
#### 参数
```python
● criterion（特征选择标准）
  ○ 可选择ceriterion=‘gini’ 或ceriterion=‘entropy’
  ○ 前者是基尼系数，后者是信息熵。两者差别不大，默认使用gini系数
● splitter（特征划分标准）
  ○ 可选择splitter='best’或splitter=‘random’
  ○ 前者在特征的所有划分点中找出最优的划分点。后者是随机的在部分划分点中找局部最优的划分点。默认使用best，它适合样本量不大的情况，若样本量较大，推荐使用random
● max_depth（决策树最大深度）
  ○ 默认为Non，可赋int值。
  ○ 在样本量多，特征多的时候，可设置max_depth来解决过拟合问题。
● min_impurity_decrease（节点划分最小不纯度）
  ○ 默认为0，可赋float值。
  ○ 这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。
● min_samples_split（内部节点再划分所需最小样本数）
  ○ 默认为2，可赋int或float值。若为float则向上取整
  ○ 顾名思义,但在样本数较少时几乎没有影响
● min_samples_leaf（叶子节点最少样本数）
  ○ 可赋int或float值
  ○ 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。
● max_leaf_nodes（最大叶子节点数）
  ○ 默认为0，可赋int值
  ○ 通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。
● min_impurity_split（信息增益的阀值）
  ○ 决策树在创建分支时，信息增益必须大于这个阀值，否则不分裂
● min_weight_fraction_leaf（叶子节点最小的样本权重和）
  ○ 默认为0，可赋float值
  ○ 这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。
● class_weight（类别权重）
  ○ 默认是non，可选择class_weight=‘balanced’
  ○ 指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数。
  ○ 另外，non不适用与回归树。
```
#### 注意

1. 当样本少数量但是样本特征非常多的时候，决策树很容易过拟合，一般来说，样本数比特征数多一些会比较容易建立健壮的模型
2. 如果样本数量少但是样本特征非常多，在拟合决策树模型前，推荐先做维度规约，比如主成分分析（PCA），特征选择（Losso）或者独立成分分析（ICA）。这样特征的维度会大大减小。再来拟合决策树模型效果会好。
3. 推荐多用决策树的可视化，同时先限制决策树的深度（比如最多3层），这样可以先观察下生成的决策树里数据的初步拟合情况，然后再决定是否要增加深度。
4. 在训练模型先，注意观察样本的类别情况（主要指分类树），如果类别分布非常不均匀，就要考虑用class_weight来限制模型过于偏向样本多的类别。
5. 决策树的数组使用的是numpy的float32类型，如果训练数据不是这样的格式，算法会先做copy再运行。
6. 如果输入的样本矩阵是稀疏的，推荐在拟合前调用csc_matrix稀疏化，在预测前调用csr_matrix稀疏化。
## 集成学习
### 随机森林
#### 代码
```python
from sklearn.ensemble import RandomForestClassifier
estimator = RandomForestClassifier(random_state=15)
estimator.fit(X_train, y_train)
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
## 特征重要程度
```python
# 打印选取的前n个特征及其重要性指标
n = 15
importances = estimator.feature_importances_
indices = np.argsort(importances)[::-1][:n]
top_features = X.columns[indices]

for i in range(len(top_features)):
    print(f"{i+1}. {top_features[i]}: {importances[indices[i]]}")
plt.figure(figsize=(17,10))
plt.bar(top_features, importances[indices])
for i, j in zip(top_features, importances[indices]):
    plt.text(i, j, '%.2f' % j, ha='center', va='bottom')

figname = '特征重要程度'
plt.title(figname)
plt.xlabel('特征')
plt.ylabel('重要程度')
```
#### 调参
#### 数据可视化

### AdaBoost
#### 参数
#### 代码
```python
from sklearn.ensemble import AdaBoostClassifier

estimator = AdaBoostClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
### ExtraTrees
#### 代码
```python
from sklearn.ensemble import ExtraTreesClassifier

estimator =  ExtraTreesClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
#### 数据可视化
### GBDT
#### 代码
```python
from sklearn.ensemble import GradientBoostingClassifier

estimator = GradientBoostingClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```

### 逻辑回归
#### 特点
适用与因变量为二项分布的情况
#### 代码
```python
from sklearn.linear_model import LogisticRegression

estimator = LogisticRegression()
estimator.fit(X_train, y_train)
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```

### SVM
#### 代码
```python
from sklearn.svm import SVC

estimator = SVC()
estimator.fit(X_train, y_train)
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
#### 数据可视化

### 朴素贝叶斯
#### 代码
```python
from sklearn.naive_bayes import GaussianNB

estimator = GaussianNB()
estimator.fit(X_train, y_train)
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
#### 数据可视化

### 
## 基于GBDT的算法
### XGBoost
#### 代码
```python
from xgboost import XGBClassifier

estimator = XGBClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
### LightGBM
#### 代码
```python
from lightgbm import LGBMClassifier

estimator = LGBMClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```
### CatBoost
#### 代码
```python
from catboost import CatBoostClassifier

estimator =  CatBoostClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```

## 神经网络
#### 代码
```python
from sklearn.neural_network import MLPClassifier

estimator = MLPClassifier()
estimator.fit(X_train, y_train)  
y_predict = estimator.predict(X_test)
print("Train set score: ", estimator.score(X_train, y_train))
print("Test set score: ", estimator.score(X_test, y_test))
```

